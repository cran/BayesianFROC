% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validation.R
\name{validation.dataset_srsc}
\alias{validation.dataset_srsc}
\title{Dataset creator from known distributions}
\usage{
validation.dataset_srsc(replicate.datset = 3, ModifiedPoisson = FALSE,
  mean.truth = 0.6, sd.truth = 5.3, z.truth = c(-0.8, 0.7, 2.38),
  NL = 259, NI = 57, ite = 1111, summary = TRUE)
}
\arguments{
\item{replicate.datset}{A Number indicate that how many you replicate dataset from user's specified dataset.}

\item{ModifiedPoisson}{Logical, that is \code{TRUE} or \code{FALSE}. If
\code{ModifiedPoisson = TRUE}, then Poisson rate of false alarm is \code{per lesion},
and if \code{ModifiedPoisson = FALSE}, then Poisson rate of false alarm is \code{per image}.
To know detail, refer the author's paper in which I explained per image and per lesion.(for details of models, see   \href{https://cran.r-project.org/package=BayesianFROC}{ vignettes  })

If \code{ModifiedPoisson = TRUE}, then False Positive Fraction (FPF) is calculated as follows
\deqn{ \frac{f_1+f_2+f_3+f_4+f_5}{N_L}, }

\deqn{ \frac{f_2+f_3+f_4+f_5}{N_L}, }

 \deqn{ \frac{f_3+f_4+f_5}{N_L}, }

  \deqn{ \frac{f_4+f_5}{N_L}, }

   \deqn{ \frac{f_5}{N_L}, }

where \eqn{N_L} is a number of lesions (signal).


On the other hand,


if \code{ModifiedPoisson = FALSE}(Default), then
\deqn{ \frac{f_1+f_2+f_3+f_4+f_5}{N_I}, }

\deqn{ \frac{f_2+f_3+f_4+f_5}{N_I}, }

 \deqn{ \frac{f_3+f_4+f_5}{N_I}, }

  \deqn{ \frac{f_4+f_5}{N_I}, }

   \deqn{ \frac{f_5}{N_I}, }

where \eqn{N_I} is a number of images (trial).


So,data of FPF and TPF are changed thus, a fitted model is also changed whether  \code{ModifiedPoisson = TRUE} or \code{FALSE}.
In traditional FROC analysis, it use only per trial. But, if we devide one image into two images or more images, number of
trial is not important. And more important is per signal. So, the author developed FROC theory to consider FROC analysis under per signal.


Revised 2019 6.19}

\item{mean.truth}{This is a parameter of the latent Gaussian assumption for the noise distribution.}

\item{sd.truth}{This is a parameter of the latent Gaussian assumption for the noise distribution.}

\item{z.truth}{This is a parameter of the latent Gaussian assumption for the noise distribution.}

\item{NL}{Number of Lesions.}

\item{NI}{Number of Images.}

\item{ite}{To be passed to the function \code{rstan::}\code{\link[rstan]{sampling}}() in \strong{rstan}. An argument of \code{rstan::}\code{\link[rstan]{sampling}}()  in which it is named \code{iter}. A positive integer representing  the  number of samples generated by Hamiltonian Monte Carlo method,
and, default = 10000. If your model could not converge, then raise this number. Must be greater for more reliable estimates.}

\item{summary}{Logical: \code{TRUE} of \code{FALSE}. Whether to print the verbose summary, i.e., logical; If \code{TRUE} then verbose summary is printed in the \R console. If \code{FALSE}, the output is minimal. I regret, this variable name should be verbose.}
}
\value{
Return values is,

stanfit objects, more precisely some inherited class, for each replicated dataset.
}
\description{
By specifying the parameters of bi-normal assumptions,
( that is, mean and sd of the signal latent Gaussian distribution)
the dataset are created from this known distributions.
The number of lesions and the number of images corresponds the sample size of each replicated dataset.

This function also fit a srsc FROC model for each replicated dataset.
}
\examples{
\donttest{
#================The first example======================================



#   Using the default values, the code run, i.e.:

   datasets <- validation.dataset_srsc()



#================The second example======================================

#   If user do not familiar with the values of thresholds, then
#   it would be better to use the actual estimated values
#    as an example of true parameters. In the following,
#     I explain this.

# First, get estimators by

  fit <- fit_Bayesian_FROC(dataList.Chakra.1,ite = 1111,summary =FALSE,cha=3)

#  Secondly, extract the expected a posterior estimators (EAPs) from the object fit

  z <- rstan::get_posterior_mean(fit,par=c("z"))[,"mean-all chains"]

#  Thirdly we use this z as a true values. If user does not know
#   the scale or ordinal values of thersholds, by using fitted values,
#     user can use this function to replicate datasets.

   datasets <- validation.dataset_srsc(z.truth = z)



}# dottest
}
